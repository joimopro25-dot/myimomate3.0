// src/utils/FirebaseService.js
// üèóÔ∏è FIREBASE SERVICE MULTI-TENANT - FOUNDATION LAYER
// =======================================================
// Sistema centralizado para gest√£o de subcole√ß√µes por utilizador
// Garante isolamento total de dados entre consultores
// Vers√£o: 3.1 Multi-Tenant | Data: Agosto 2025

import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  getDocs, 
  getDoc,
  query, 
  where, 
  orderBy, 
  limit,
  startAfter,
  serverTimestamp,
  writeBatch,
  runTransaction
} from 'firebase/firestore';
import { db } from '../config/firebase';

// üéØ ESTRUTURA MULTI-TENANT CENTRALIZADA
// =====================================

/**
 * Nomes das subcole√ß√µes por utilizador
 */
export const SUBCOLLECTIONS = {
  LEADS: 'leads',
  CLIENTS: 'clients', 
  OPPORTUNITIES: 'opportunities',
  DEALS: 'deals',
  VISITS: 'visits',
  TASKS: 'tasks',
  ACTIVITIES: 'activities',
  DOCUMENTS: 'documents',
  SETTINGS: 'settings'
};

/**
 * Configura√ß√µes globais do servi√ßo
 */
const CONFIG = {
  DEFAULT_PAGE_SIZE: 50,
  MAX_PAGE_SIZE: 100,
  BATCH_SIZE: 500,
  RETRY_ATTEMPTS: 3,
  TIMEOUT_MS: 10000
};

// üîß CORE FIRESTORE SERVICE CLASS
// ===============================

class FirebaseService {
  constructor() {
    this.currentUser = null;
    this.cache = new Map();
    this.listeners = new Map();
  }

  /**
   * üîê Definir utilizador atual (obrigat√≥rio para todas as opera√ß√µes)
   */
  setCurrentUser(user) {
    if (!user || !user.uid) {
      throw new Error('FirebaseService: utilizador inv√°lido');
    }
    
    this.currentUser = user;
    console.log(`üîê FirebaseService: Utilizador definido: ${user.uid}`);
    
    // Limpar cache quando mudar utilizador
    this.cache.clear();
    this.clearAllListeners();
  }

  /**
   * üìÅ Obter refer√™ncia para subcole√ß√£o do utilizador
   */
  getUserSubcollection(subcollectionName) {
    if (!this.currentUser) {
      throw new Error('FirebaseService: Utilizador n√£o definido. Use setCurrentUser() primeiro.');
    }

    const userDocRef = doc(db, 'users', this.currentUser.uid);
    return collection(userDocRef, subcollectionName);
  }

  /**
   * üìù Obter refer√™ncia para documento espec√≠fico na subcole√ß√£o
   */
  getUserDocument(subcollectionName, documentId) {
    if (!this.currentUser) {
      throw new Error('FirebaseService: Utilizador n√£o definido. Use setCurrentUser() primeiro.');
    }

    const userDocRef = doc(db, 'users', this.currentUser.uid);
    const subcollectionRef = collection(userDocRef, subcollectionName);
    return doc(subcollectionRef, documentId);
  }

  // üìä OPERA√á√ïES CRUD PARA SUBCOLE√á√ïES
  // =================================

  /**
   * ‚ûï Criar documento numa subcole√ß√£o
   */
  async createDocument(subcollectionName, data) {
    try {
      const subcollectionRef = this.getUserSubcollection(subcollectionName);
      
      // Adicionar metadados obrigat√≥rios
      const enrichedData = {
        ...data,
        userId: this.currentUser.uid,
        userEmail: this.currentUser.email,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        createdBy: this.currentUser.uid,
        lastModifiedBy: this.currentUser.uid,
        isActive: data.isActive !== undefined ? data.isActive : true,
        structureVersion: '3.1'
      };

      const docRef = await addDoc(subcollectionRef, enrichedData);
      
      console.log(`‚ûï Documento criado em ${subcollectionName}: ${docRef.id}`);
      
      // Invalidar cache
      this.invalidateCache(subcollectionName);
      
      return {
        success: true,
        id: docRef.id,
        data: { ...enrichedData, id: docRef.id }
      };

    } catch (error) {
      console.error(`‚ùå Erro ao criar em ${subcollectionName}:`, error);
      throw new Error(`Falha ao criar documento: ${error.message}`);
    }
  }

  /**
   * üìñ Ler documentos de uma subcole√ß√£o
   */
  async readDocuments(subcollectionName, options = {}) {
    try {
      const {
        orderBy: orderByField = 'createdAt',
        orderDirection = 'desc',
        limitCount = CONFIG.DEFAULT_PAGE_SIZE,
        where: whereConditions = [],
        startAfterDoc = null,
        includeInactive = false
      } = options;

      // Verificar cache primeiro
      const cacheKey = this.getCacheKey(subcollectionName, options);
      if (this.cache.has(cacheKey)) {
        console.log(`üíæ Cache hit para ${subcollectionName}`);
        return this.cache.get(cacheKey);
      }

      const subcollectionRef = this.getUserSubcollection(subcollectionName);
      
      // Construir query
      let q = query(subcollectionRef);

      // Filtro por ativo (se n√£o especificado incluir inativos)
      if (!includeInactive) {
        q = query(q, where('isActive', '==', true));
      }

      // Adicionar condi√ß√µes where personalizadas
      whereConditions.forEach(condition => {
        q = query(q, where(condition.field, condition.operator, condition.value));
      });

      // Ordena√ß√£o
      q = query(q, orderBy(orderByField, orderDirection));

      // Limite
      if (limitCount && limitCount > 0) {
        q = query(q, limit(Math.min(limitCount, CONFIG.MAX_PAGE_SIZE)));
      }

      // Pagina√ß√£o
      if (startAfterDoc) {
        q = query(q, startAfter(startAfterDoc));
      }

      const snapshot = await getDocs(q);
      const documents = [];

      snapshot.forEach(doc => {
        documents.push({
          id: doc.id,
          ...doc.data(),
          // Converter timestamps para dates se necess√°rio
          createdAt: doc.data().createdAt?.toDate() || null,
          updatedAt: doc.data().updatedAt?.toDate() || null
        });
      });

      console.log(`üìñ Lidos ${documents.length} documentos de ${subcollectionName}`);

      // Cache resultado
      const result = {
        success: true,
        data: documents,
        count: documents.length,
        hasMore: documents.length === limitCount
      };

      this.cache.set(cacheKey, result);
      
      return result;

    } catch (error) {
      console.error(`‚ùå Erro ao ler ${subcollectionName}:`, error);
      throw new Error(`Falha ao ler documentos: ${error.message}`);
    }
  }

  /**
   * üìñ Ler documento espec√≠fico
   */
  async readDocument(subcollectionName, documentId) {
    try {
      const docRef = this.getUserDocument(subcollectionName, documentId);
      const docSnap = await getDoc(docRef);

      if (!docSnap.exists()) {
        return {
          success: false,
          error: 'Documento n√£o encontrado',
          data: null
        };
      }

      const data = {
        id: docSnap.id,
        ...docSnap.data(),
        createdAt: docSnap.data().createdAt?.toDate() || null,
        updatedAt: docSnap.data().updatedAt?.toDate() || null
      };

      console.log(`üìñ Documento lido: ${subcollectionName}/${documentId}`);

      return {
        success: true,
        data
      };

    } catch (error) {
      console.error(`‚ùå Erro ao ler documento ${subcollectionName}/${documentId}:`, error);
      throw new Error(`Falha ao ler documento: ${error.message}`);
    }
  }

  /**
   * ‚úèÔ∏è Atualizar documento
   */
  async updateDocument(subcollectionName, documentId, updates) {
    try {
      const docRef = this.getUserDocument(subcollectionName, documentId);
      
      // Adicionar metadados de atualiza√ß√£o
      const enrichedUpdates = {
        ...updates,
        updatedAt: serverTimestamp(),
        lastModifiedBy: this.currentUser.uid
      };

      await updateDoc(docRef, enrichedUpdates);
      
      console.log(`‚úèÔ∏è Documento atualizado: ${subcollectionName}/${documentId}`);
      
      // Invalidar cache
      this.invalidateCache(subcollectionName);
      
      return {
        success: true,
        id: documentId,
        message: 'Documento atualizado com sucesso'
      };

    } catch (error) {
      console.error(`‚ùå Erro ao atualizar ${subcollectionName}/${documentId}:`, error);
      throw new Error(`Falha ao atualizar documento: ${error.message}`);
    }
  }

  /**
   * üóëÔ∏è Eliminar documento (soft delete por padr√£o)
   */
  async deleteDocument(subcollectionName, documentId, hardDelete = false) {
    try {
      const docRef = this.getUserDocument(subcollectionName, documentId);

      if (hardDelete) {
        // Elimina√ß√£o permanente
        await deleteDoc(docRef);
        console.log(`üóëÔ∏è Documento eliminado permanentemente: ${subcollectionName}/${documentId}`);
      } else {
        // Soft delete - marcar como inativo
        await updateDoc(docRef, {
          isActive: false,
          deletedAt: serverTimestamp(),
          deletedBy: this.currentUser.uid,
          updatedAt: serverTimestamp(),
          lastModifiedBy: this.currentUser.uid
        });
        console.log(`üóëÔ∏è Documento marcado como inativo: ${subcollectionName}/${documentId}`);
      }
      
      // Invalidar cache
      this.invalidateCache(subcollectionName);
      
      return {
        success: true,
        id: documentId,
        message: hardDelete ? 'Documento eliminado permanentemente' : 'Documento marcado como inativo'
      };

    } catch (error) {
      console.error(`‚ùå Erro ao eliminar ${subcollectionName}/${documentId}:`, error);
      throw new Error(`Falha ao eliminar documento: ${error.message}`);
    }
  }

  // üîÑ OPERA√á√ïES AVAN√áADAS
  // =====================

  /**
   * üìä Contar documentos numa subcole√ß√£o
   */
  async countDocuments(subcollectionName, whereConditions = [], includeInactive = false) {
    try {
      const result = await this.readDocuments(subcollectionName, {
        where: whereConditions,
        includeInactive,
        limitCount: null // Sem limite para contar tudo
      });

      return {
        success: true,
        count: result.data.length
      };

    } catch (error) {
      console.error(`‚ùå Erro ao contar ${subcollectionName}:`, error);
      throw new Error(`Falha ao contar documentos: ${error.message}`);
    }
  }

  /**
   * üîÑ Opera√ß√£o batch (m√∫ltiplas opera√ß√µes numa transa√ß√£o)
   */
  async batchOperation(operations) {
    try {
      const batch = writeBatch(db);

      for (const operation of operations) {
        const { type, subcollectionName, documentId, data } = operation;

        switch (type) {
          case 'create':
            const createRef = doc(this.getUserSubcollection(subcollectionName));
            batch.set(createRef, {
              ...data,
              userId: this.currentUser.uid,
              userEmail: this.currentUser.email,
              createdAt: serverTimestamp(),
              updatedAt: serverTimestamp(),
              createdBy: this.currentUser.uid,
              lastModifiedBy: this.currentUser.uid
            });
            break;

          case 'update':
            const updateRef = this.getUserDocument(subcollectionName, documentId);
            batch.update(updateRef, {
              ...data,
              updatedAt: serverTimestamp(),
              lastModifiedBy: this.currentUser.uid
            });
            break;

          case 'delete':
            const deleteRef = this.getUserDocument(subcollectionName, documentId);
            if (operation.hardDelete) {
              batch.delete(deleteRef);
            } else {
              batch.update(deleteRef, {
                isActive: false,
                deletedAt: serverTimestamp(),
                deletedBy: this.currentUser.uid,
                updatedAt: serverTimestamp()
              });
            }
            break;
        }
      }

      await batch.commit();
      
      console.log(`üîÑ Batch de ${operations.length} opera√ß√µes executado com sucesso`);
      
      // Invalidar cache de todas as subcole√ß√µes afetadas
      const affectedSubcollections = [...new Set(operations.map(op => op.subcollectionName))];
      affectedSubcollections.forEach(subcol => this.invalidateCache(subcol));
      
      return {
        success: true,
        operationsCount: operations.length,
        message: 'Todas as opera√ß√µes executadas com sucesso'
      };

    } catch (error) {
      console.error('‚ùå Erro na opera√ß√£o batch:', error);
      throw new Error(`Falha na opera√ß√£o batch: ${error.message}`);
    }
  }

  /**
   * üîÑ Transa√ß√£o (para opera√ß√µes que requerem consist√™ncia)
   */
  async runTransaction(transactionFunction) {
    try {
      const result = await runTransaction(db, async (transaction) => {
        return await transactionFunction(transaction, this);
      });

      console.log('üîÑ Transa√ß√£o executada com sucesso');
      
      return {
        success: true,
        result,
        message: 'Transa√ß√£o executada com sucesso'
      };

    } catch (error) {
      console.error('‚ùå Erro na transa√ß√£o:', error);
      throw new Error(`Falha na transa√ß√£o: ${error.message}`);
    }
  }

  // üíæ SISTEMA DE CACHE
  // ==================

  /**
   * üîë Gerar chave de cache
   */
  getCacheKey(subcollectionName, options) {
    return `${this.currentUser?.uid}_${subcollectionName}_${JSON.stringify(options)}`;
  }

  /**
   * üóëÔ∏è Invalidar cache de uma subcole√ß√£o
   */
  invalidateCache(subcollectionName) {
    const keysToDelete = [];
    
    for (const [key] of this.cache) {
      if (key.includes(`_${subcollectionName}_`)) {
        keysToDelete.push(key);
      }
    }
    
    keysToDelete.forEach(key => this.cache.delete(key));
    console.log(`üíæ Cache invalidado para ${subcollectionName}: ${keysToDelete.length} entradas removidas`);
  }

  /**
   * üßπ Limpar todo o cache
   */
  clearCache() {
    this.cache.clear();
    console.log('üíæ Cache completamente limpo');
  }

  // üëÇ SISTEMA DE LISTENERS
  // ======================

  /**
   * üëÇ Adicionar listener em tempo real
   */
  addRealtimeListener(subcollectionName, callback, options = {}) {
    const listenerId = `${subcollectionName}_${Date.now()}`;
    
    // TODO: Implementar listeners em tempo real
    // Por agora, fazer polling simples
    console.log(`üëÇ Listener adicionado: ${listenerId}`);
    
    return listenerId;
  }

  /**
   * üîá Remover listener
   */
  removeListener(listenerId) {
    if (this.listeners.has(listenerId)) {
      this.listeners.get(listenerId)();
      this.listeners.delete(listenerId);
      console.log(`üîá Listener removido: ${listenerId}`);
    }
  }

  /**
   * üîá Remover todos os listeners
   */
  clearAllListeners() {
    this.listeners.forEach(unsubscribe => unsubscribe());
    this.listeners.clear();
    console.log('üîá Todos os listeners removidos');
  }

  // üß™ UTILIDADES DE DIAGN√ìSTICO
  // ============================

  /**
   * üîç Diagnosticar subcole√ß√£o
   */
  async diagnoseSubcollection(subcollectionName) {
    try {
      const result = await this.readDocuments(subcollectionName, {
        limitCount: 5,
        includeInactive: true
      });

      const diagnosis = {
        subcollection: subcollectionName,
        userId: this.currentUser.uid,
        totalDocuments: result.count,
        sampleDocuments: result.data,
        cacheStatus: this.cache.size > 0 ? 'active' : 'empty',
        timestamp: new Date().toISOString()
      };

      console.log(`üîç Diagn√≥stico ${subcollectionName}:`, diagnosis);
      
      return diagnosis;

    } catch (error) {
      console.error(`‚ùå Erro no diagn√≥stico ${subcollectionName}:`, error);
      return {
        subcollection: subcollectionName,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * üìä Status geral do servi√ßo
   */
  getServiceStatus() {
    return {
      currentUser: this.currentUser ? {
        uid: this.currentUser.uid,
        email: this.currentUser.email
      } : null,
      cacheSize: this.cache.size,
      activeListeners: this.listeners.size,
      timestamp: new Date().toISOString()
    };
  }
}

// üè≠ INST√ÇNCIA SINGLETON
// ======================
const firebaseService = new FirebaseService();

// üöÄ EXPORTS
// ==========
export default firebaseService;

// Exports nomeados para facilitar importa√ß√£o
export {
  firebaseService,
  SUBCOLLECTIONS,
  CONFIG as FIREBASE_CONFIG
};

// üéØ HELPER FUNCTIONS PARA HOOKS
// ==============================

/**
 * üé£ Hook helper para inicializar servi√ßo com user
 */
export const useFirebaseService = (user) => {
  if (user && firebaseService.currentUser?.uid !== user.uid) {
    firebaseService.setCurrentUser(user);
  }
  
  return firebaseService;
};

/**
 * üìã Helper para opera√ß√µes CRUD simples
 */
export const createCRUDHelpers = (subcollectionName) => {
  return {
    create: (data) => firebaseService.createDocument(subcollectionName, data),
    read: (options) => firebaseService.readDocuments(subcollectionName, options),
    readOne: (id) => firebaseService.readDocument(subcollectionName, id),
    update: (id, data) => firebaseService.updateDocument(subcollectionName, id, data),
    delete: (id, hard = false) => firebaseService.deleteDocument(subcollectionName, id, hard),
    count: (where, includeInactive) => firebaseService.countDocuments(subcollectionName, where, includeInactive)
  };
};